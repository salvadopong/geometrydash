<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Dash: Editor & Spacing Fixes V7</title>
    <style>
        :root {
            --primary: #00f0ff;
            --secondary: #ff0055;
            --bg: #121212;
            --panel: rgba(15, 15, 25, 0.95);
            --font-main: 'Orbitron', sans-serif;
            /* Default Player Colors (Will be updated by JS) */
            --player-main: #00f0ff;
            --player-sec: #ff0055;
        }
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0; overflow: hidden; background-color: var(--bg);
            font-family: var(--font-main); color: white; user-select: none;
        }

        #game-container { position: relative; width: 100vw; height: 100vh; background: #000; }
        canvas { display: block; width: 100%; height: 100%; }

        /* UI LAYERS */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: 0.3s; z-index: 10;
        }
        .hidden { opacity: 0; pointer-events: none; transform: scale(1.1); }
        .visible { opacity: 1; pointer-events: all; transform: scale(1); }

        .menu-box {
            background: var(--panel); padding: 40px; border-radius: 12px;
            border: 2px solid var(--primary); 
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            text-align: center; min-width: 350px;
        }

        /* FLASHY TITLE EFFECT */
        @keyframes pulse {
            0% { text-shadow: 0 0 5px var(--primary); }
            50% { text-shadow: 0 0 20px var(--primary), 0 0 30px rgba(0, 240, 255, 0.5); }
            100% { text-shadow: 0 0 5px var(--primary); }
        }

        h1 {
            font-size: 3.5rem; margin: 0 0 10px 0; text-transform: uppercase;
            background: linear-gradient(to bottom, #fff, var(--primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: pulse 2s infinite alternate;
        }

        button {
            background: linear-gradient(180deg, #333, #111);
            border: 1px solid #555; color: #fff;
            padding: 15px 30px; font-family: var(--font-main); font-size: 1.2rem;
            margin: 10px; cursor: pointer; text-transform: uppercase; font-weight: bold;
            box-shadow: 0 4px 0 #000; transition: transform 0.1s;
        }
        button:active { transform: translateY(4px); box-shadow: 0 0 0 #000; }
        button:hover { border-color: var(--primary); color: var(--primary); }
        
        button.secondary { background: linear-gradient(180deg, #311, #100); }
        button.secondary:hover { border-color: var(--secondary); color: var(--secondary); }
        
        button.next { background: linear-gradient(180deg, #0a0, #040); border-color: #0f0; }
        button.next:hover { color: #0f0; }

        /* Customization Area */
        .color-selector {
            display: flex; justify-content: space-around; margin-top: 20px;
            padding: 15px; border: 1px dashed #333;
        }
        .color-group { text-align: left; }
        .color-group label { display: block; font-size: 0.9rem; margin-bottom: 5px; color: #aaa; }
        .color-group input[type="color"] {
            width: 80px; height: 40px; border: none; padding: 0; cursor: pointer;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.2);
        }

        /* LEVEL GRID */
        .level-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin: 20px 0; }
        .lvl-btn {
            width: 60px; height: 60px; font-size: 1.5rem;
            display: flex; justify-content: center; align-items: center;
            background: #222; border: 2px solid #444; cursor: pointer; position: relative;
        }
        .lvl-btn:hover { border-color: var(--primary); background: #333; }
        .lvl-btn.locked { 
            background: #000; border-color: #222; color: #333; cursor: not-allowed; 
        }
        .lvl-btn.locked::after {
            content: 'ðŸ”’'; font-size: 1rem; position: absolute;
        }

        /* EDITOR UI */
        #editor-ui {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #111; padding: 10px; border-radius: 10px; border: 1px solid #333;
            display: flex; gap: 5px; pointer-events: all;
        }
        .tool {
            width: 40px; height: 40px; border: 1px solid #444; cursor: pointer;
            display: flex; justify-content: center; align-items: center; font-size: 0.7rem; font-weight: bold;
        }
        .tool.active { background: var(--primary); color: black; border-color: white; }

        /* HUD */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none;
        }
        .progress-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 60%; height: 10px; background: rgba(255,255,255,0.1); border: 1px solid #fff;
        }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; }
        
        #msg {
            position: absolute; top: 30%; width: 100%; text-align: center;
            font-size: 4rem; font-weight: 900; opacity: 0; transition: 0.5s;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="msg">MODE</div>

        <div id="hud">
            <div style="position: absolute; top:15px; left:20px; font-size:1.2rem;">ATTEMPT <span id="att">1</span></div>
            <div class="progress-bar"><div class="progress-fill" id="prog"></div></div>
        </div>

        <div id="menu-main" class="ui-layer visible">
            <div class="menu-box">
                <h1>NEON DASH</h1>
                <p style="letter-spacing:4px; color:#888; font-size:0.8rem; margin-top:-10px;">V7.0</p>
                <button onclick="UI.showLevels()">Play Levels</button>
                <button class="secondary" onclick="UI.showEditor()">Level Editor</button>
                
                <div class="color-selector">
                    <div class="color-group">
                        <label for="main-color">Primary Color</label>
                        <input type="color" id="main-color" oninput="Player.setColors()">
                    </div>
                    <div class="color-group">
                        <label for="secondary-color">Secondary Color</label>
                        <input type="color" id="secondary-color" oninput="Player.setColors()">
                    </div>
                </div>

                <div style="margin-top:10px; font-size: 0.8rem; color:#666;">
                    Controls: **Space/â†‘** (Action), **R** (Reset)
                </div>
                <div style="margin-top:5px; font-size: 0.8rem; color:#666;">
                    Levels unlocked: <span id="unlock-count">1</span>/10
                </div>
            </div>
        </div>

        <div id="menu-levels" class="ui-layer hidden">
            <div class="menu-box">
                <h2>SELECT SECTOR</h2>
                <div class="level-grid" id="lvl-grid"></div>
                <button class="secondary" onclick="Game.loadCustom()">CUSTOM</button>
                <br>
                <button onclick="UI.home()">BACK</button>
            </div>
        </div>

        <div id="menu-pause" class="ui-layer hidden">
            <div class="menu-box">
                <h1 id="pause-title" style="font-size: 2.5rem;">CRASHED</h1>
                <p id="pause-p">0%</p>
                <button id="pause-main-btn" onclick="Game.retry()">RETRY (R Key)</button>
                <button class="secondary" onclick="UI.home()">MENU</button>
            </div>
        </div>

        <div id="editor-overlay" class="ui-layer hidden" style="pointer-events: none;">
            <div id="editor-ui">
                <div class="tool active" onclick="Editor.tool=1">BLK</div>
                <div class="tool" onclick="Editor.tool=2">SPK</div>
                <div class="tool" onclick="Editor.tool=7">PAD</div>
                <div class="tool" onclick="Editor.tool=3">ORB</div>
                <div class="tool" style="border-color:#0f0; color:#0f0;" onclick="Editor.tool=4">SHP</div>
                <div class="tool" style="border-color:#fa0; color:#fa0;" onclick="Editor.tool=5">UFO</div>
                <div class="tool" style="border-color:#0ff; color:#0ff;" onclick="Editor.tool=6">CUB</div>
                <div class="tool" style="border-color:#f55; color:#f55;" onclick="Editor.tool=0">DEL</div>
                <div style="width:10px"></div>
                <div class="tool secondary" onclick="Editor.test()">GO</div>
                <div class="tool secondary" onclick="Editor.save()">SAV</div>
                <div class="tool secondary" onclick="UI.home()">X</div>
            </div>
            <div style="position: absolute; top:20px; right:20px; text-align: right; pointer-events: all;">
                <p>Arrows: Camera | Click: Place</p>
            </div>
        </div>
    </div>

<script>
// --- CONFIGURATION ---
const CFG = {
    g: 0.8,       
    jmp: 15.0,    
    spd: 8.5,     
    term: 18,     
    tile: 50,
    maxHeight: -250, 
};

// --- AUDIO (Synthesizer) ---
const AUDIO = {
    ctx: null,
    init: function() { if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)(); },
    tone: function(f, t, d, v=0.1, s=0) {
        if(!this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type=t; o.frequency.value=f; 
        if(s) o.frequency.linearRampToValueAtTime(s, this.ctx.currentTime+d);
        g.gain.setValueAtTime(v, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime+d);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime+d);
    },
    jump: () => AUDIO.tone(100, 'square', 0.1, 0.1),
    die: () => AUDIO.tone(80, 'sawtooth', 0.4, 0.2, 10),
    orb: () => AUDIO.tone(600, 'sine', 0.1, 0.1, 1200),
    pad: () => AUDIO.tone(300, 'square', 0.2, 0.1, 800),
    win: () => { AUDIO.tone(440,'triangle',0.1); setTimeout(()=>AUDIO.tone(554,'triangle',0.1),100); setTimeout(()=>AUDIO.tone(660,'triangle',0.4),200); }
};

// --- LEVEL DATA (Adjusted for V7 - Safer Start & Physics Check) ---
// t: 1=Block, 2=Spike, 3=Orb, 4=Ship, 5=UFO, 6=Cube, 7=Pad, 99=Goal
const LEVELS = [
    // 1. SIMPLE DASH (Start at X=10, obstacle at 15)
    [{t:1,x:10,y:0},{t:1,x:11,y:0},{t:2,x:15,y:0},{t:1,x:19,y:1},{t:2,x:23,y:0},{t:7,x:26,y:0},{t:1,x:30,y:2},{t:1,x:31,y:2},{t:2,x:34,y:0},{t:1,x:38,y:0},{t:1,x:39,y:0},{t:2,x:40,y:1},{t:1,x:44,y:1},{t:1,x:49,y:3},{t:2,x:54,y:0},{t:99,x:69,y:0}],
    
    // 2. BOUNCING BLOCKS
    [{t:1,x:4,y:0},{t:7,x:12,y:0},{t:1,x:18,y:3},{t:1,x:19,y:3},{t:2,x:23,y:0},{t:7,x:27,y:0},{t:1,x:32,y:4},{t:2,x:35,y:0},{t:1,x:39,y:2},{t:7,x:40,y:2},{t:1,x:45,y:5},{t:2,x:48,y:0},{t:7,x:51,y:0},{t:1,x:54,y:3},{t:99,x:74,y:0}],
    
    // 3. ORB RIDER
    [{t:1,x:10,y:0},{t:2,x:14,y:0},{t:3,x:17,y:2},{t:1,x:20,y:1},{t:2,x:23,y:0},{t:3,x:27,y:4},{t:1,x:31,y:3},{t:2,x:34,y:0},{t:1,x:38,y:1},{t:3,x:42,y:4},{t:3,x:46,y:4},{t:1,x:50,y:2},{t:2,x:54,y:0},{t:3,x:58,y:1},{t:99,x:70,y:0}],
    
    // 4. SHIP INITIATE
    [{t:1,x:10,y:0},{t:4,x:14,y:1},{t:1,x:21,y:6},{t:1,x:26,y:0},{t:1,x:31,y:7},{t:1,x:36,y:1},{t:1,x:41,y:8},{t:6,x:48,y:2},{t:2,x:51,y:0},{t:1,x:56,y:1},{t:99,x:70,y:0}],
    
    // 5. SHIP PRECISION
    [{t:1,x:4,y:0},{t:4,x:9,y:1},{t:1,x:14,y:0},{t:1,x:14,y:8},{t:1,x:20,y:2},{t:1,x:20,y:9},{t:1,x:26,y:1},{t:1,x:26,y:7},{t:1,x:32,y:3},{t:1,x:32,y:8},{t:1,x:39,y:0},{t:1,x:39,y:6},{t:6,x:46,y:3},{t:2,x:49,y:0},{t:1,x:54,y:1},{t:99,x:75,y:0}],
    
    // 6. MODE MIX
    [{t:1,x:10,y:0},{t:3,x:14,y:3},{t:1,x:18,y:2},{t:4,x:22,y:3},{t:1,x:30,y:5},{t:1,x:35,y:2},{t:6,x:41,y:2},{t:2,x:45,y:0},{t:7,x:48,y:0},{t:1,x:52,y:4},{t:2,x:55,y:0},{t:1,x:58,y:1},{t:99,x:80,y:0}],
    
    // 7. SAUCER START
    [{t:1,x:4,y:0},{t:5,x:9,y:1},{t:1,x:14,y:0},{t:1,x:18,y:3},{t:1,x:22,y:0},{t:1,x:26,y:4},{t:1,x:30,y:0},{t:1,x:34,y:5},{t:6,x:39,y:2},{t:3,x:44,y:3},{t:1,x:48,y:0},{t:7,x:51,y:0},{t:99,x:70,y:0}],
    
    // 8. TIGHT CUBE
    [{t:1,x:10,y:0},{t:2,x:12,y:1},{t:1,x:15,y:1},{t:3,x:18,y:3},{t:2,x:22,y:0},{t:1,x:26,y:2},{t:2,x:29,y:2},{t:1,x:32,y:3},{t:3,x:36,y:5},{t:1,x:40,y:1},{t:2,x:44,y:0},{t:2,x:45,y:0},{t:1,x:50,y:1},{t:7,x:53,y:0},{t:99,x:75,y:0}],
    
    // 9. DYNAMIC DIVE
    [{t:1,x:4,y:0},{t:4,x:10,y:1},{t:1,x:17,y:5},{t:1,x:23,y:1},{t:6,x:28,y:3},{t:1,x:31,y:0},{t:7,x:34,y:0},{t:5,x:39,y:5},{t:1,x:45,y:2},{t:6,x:51,y:2},{t:2,x:55,y:0},{t:1,x:58,y:1},{t:99,x:80,y:0}],
    
    // 10. REAL TEST
    [{t:1,x:4,y:0},{t:4,x:10,y:3}, ...Array.from({length:10},(_,i)=>({t:1,x:15+i,y:0})), ...Array.from({length:10},(_,i)=>({t:1,x:15+i,y:8})), 
     {t:1,x:23,y:5},{t:2,x:25,y:1},{t:6,x:30,y:3},{t:1,x:35,y:0},{t:3,x:39,y:2},{t:5,x:43,y:1},{t:1,x:49,y:4},{t:6,x:55,y:2},{t:2,x:60,y:0},{t:99,x:85,y:0}]
];

// --- PROGRESSION ---
let unlocked = parseInt(localStorage.getItem('nd_level') || 1);

// --- ENGINE ---
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    state: 'menu', 
    level: [], 
    att: 1, 
    camX: 0, 
    floorY: 0,
    shake: 0,
    currLvlIdx: 0,
    pauseBtn: document.getElementById('pause-main-btn'),

    init: function() {
        this.resize();
        window.onresize = ()=>this.resize();
        document.getElementById('unlock-count').innerText = unlocked;
        Player.loadColors(); // Load custom colors
        this.loop();
    },
    resize: function() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.floorY = this.canvas.height - 150;
    },
    loadLevel: function(idx) {
        if(idx >= LEVELS.length) return;
        this.currLvlIdx = idx;
        // The first obstacle block usually starts around X=10 to X=15.
        // We set the player start position (Player.x) in Player.reset() to X=20
        this.level = JSON.parse(JSON.stringify(LEVELS[idx]));
        this.start();
    },
    loadCustom: function() {
        let d = localStorage.getItem('nd_custom');
        if(!d) return alert("No Saved Level!");
        this.currLvlIdx = -1;
        this.level = JSON.parse(d);
        this.start();
    },
    start: function() {
        this.state = 'game';
        Player.reset();
        this.camX = 0;
        this.att = 1;
        UI.hide();
        document.getElementById('hud').style.display = 'block';
        document.getElementById('att').innerText = this.att;
    },
    retry: function() {
        if (this.state === 'game' || this.state === 'dead' || this.state === 'win') {
            this.state = 'game';
            Player.reset();
            this.att++;
            document.getElementById('att').innerText = this.att;
            UI.hide();
        }
    },
    win: function() {
        this.state = 'win';
        AUDIO.win();
        document.getElementById('pause-title').innerText = "COMPLETE!";
        document.getElementById('pause-p').innerText = "100%";
        
        if(this.currLvlIdx !== -1 && this.currLvlIdx < 9) {
            if (this.currLvlIdx + 2 > unlocked) {
                unlocked = Math.min(10, this.currLvlIdx + 2);
                localStorage.setItem('nd_level', unlocked);
                document.getElementById('unlock-count').innerText = unlocked;
            }
            this.pauseBtn.innerText = "NEXT LEVEL";
            this.pauseBtn.className = "next";
            this.pauseBtn.onclick = () => Game.loadLevel(this.currLvlIdx + 1);
        } else {
            this.pauseBtn.innerText = "RETRY (R Key)";
            this.pauseBtn.className = "";
            this.pauseBtn.onclick = () => Game.retry();
        }

        UI.show('menu-pause');
    },
    crash: function() {
        if(this.state !== 'game') return;
        this.state = 'dead';
        AUDIO.die();
        this.shake = 20;
        
        let endX = 0;
        this.level.forEach(o => { if(o.t===99) endX = o.x*CFG.tile; });
        let pct = Math.floor((Player.x / endX)*100);
        
        setTimeout(() => {
            document.getElementById('pause-title').innerText = "CRASHED";
            document.getElementById('pause-p').innerText = pct + "%";
            this.pauseBtn.innerText = "RETRY (R Key)";
            this.pauseBtn.className = "";
            this.pauseBtn.onclick = () => Game.retry();
            UI.show('menu-pause');
        }, 800);
    },
    
    loop: function() {
        let ctx = this.ctx;
        
        // Dynamic Background Color
        let hue = (Player.x / 100) % 360;
        ctx.fillStyle = `hsl(${hue}, 15%, 10%)`;
        ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
        
        ctx.save();
        if(this.shake>0) {
            ctx.translate((Math.random()-.5)*this.shake, (Math.random()-.5)*this.shake);
            this.shake*=0.9;
        }
        
        // Physics
        if(this.state === 'game') {
            Player.update();
            this.camX = Player.x - 300;
        }

        // Camera Y
        let targetY = Player.y * 0.6;
        let camY = (this.canvas.height - 200) - targetY;
        
        // Draw Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.lineWidth = 2;
        let ox = -(this.camX % CFG.tile);
        for(let i=ox; i<this.canvas.width; i+=CFG.tile) {
            ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i-100, this.canvas.height); ctx.stroke();
        }

        // Draw Floor
        ctx.fillStyle = '#00f0ff';
        ctx.fillRect(0, camY, this.canvas.width, 2);
        ctx.fillStyle = '#111';
        ctx.fillRect(0, camY+2, this.canvas.width, 500);

        // Draw Objects
        this.level.forEach(o => {
            let dx = o.x * CFG.tile - this.camX;
            let dy = camY - (o.y * CFG.tile) - CFG.tile;
            if(dx < -CFG.tile || dx > this.canvas.width) return;

            if(o.t===1) { // Block
                ctx.fillStyle = '#00f0ff'; ctx.fillRect(dx,dy,CFG.tile,CFG.tile);
                ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.strokeRect(dx,dy,CFG.tile,CFG.tile);
                ctx.fillStyle='rgba(0,0,0,0.4)'; ctx.fillRect(dx+5,dy+5,CFG.tile-10,CFG.tile-10);
            } 
            else if (o.t===2) { // Spike
                ctx.fillStyle='#f22'; ctx.beginPath();
                ctx.moveTo(dx+10, dy+CFG.tile); ctx.lineTo(dx+25, dy+5); ctx.lineTo(dx+40, dy+CFG.tile);
                ctx.fill(); ctx.strokeStyle='#fff'; ctx.stroke();
            }
            else if (o.t===3) { // Orb
                ctx.fillStyle='#ff0'; ctx.beginPath(); ctx.arc(dx+25,dy+25,12,0,7); ctx.fill();
                ctx.strokeStyle='#ff0'; ctx.beginPath(); ctx.arc(dx+25,dy+25,20,0,7); ctx.stroke();
            }
            else if (o.t===7) { // Pad
                ctx.fillStyle='#ff0'; ctx.fillRect(dx+5, dy+40, 40, 10);
                ctx.strokeStyle='#fff'; ctx.strokeRect(dx+5, dy+40, 40, 10);
            }
            else if (o.t===99) { // Goal
                ctx.fillStyle='#0f0'; ctx.globalAlpha=0.3; ctx.fillRect(dx, -500, 100, 2000); ctx.globalAlpha=1;
            }
            else { // Portals
                let c = o.t===4?'#0f0':(o.t===5?'#fa0':'#0ff');
                ctx.strokeStyle=c; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100);
            }
        });

        // Player
        if(this.state !== 'editor' && this.state !== 'dead') Player.draw(ctx, camY);

        // Progress Bar
        if(this.state === 'game') {
            let end = this.level.find(o=>o.t===99);
            if(end) {
                let p = Math.max(0, Math.min(100, (Player.x / (end.x*CFG.tile))*100));
                document.getElementById('prog').style.width = p+'%';
            }
        }

        ctx.restore();
        requestAnimationFrame(()=>this.loop());
    }
};

// --- PLAYER PHYSICS ---
const Player = {
    x:0, y:0, w:40, h:40, 
    dx: CFG.spd, dy:0, 
    mode:'cube', angle:0, onGround:false,
    mainColor: '#00f0ff',
    secondaryColor: '#ff0055',

    loadColors: function() {
        this.mainColor = localStorage.getItem('nd_main_color') || '#00f0ff';
        this.secondaryColor = localStorage.getItem('nd_sec_color') || '#ff0055';

        document.documentElement.style.setProperty('--player-main', this.mainColor);
        document.documentElement.style.setProperty('--player-sec', this.secondaryColor);
        
        const mainInput = document.getElementById('main-color');
        const secondaryInput = document.getElementById('secondary-color');
        if (mainInput) mainInput.value = this.mainColor;
        if (secondaryInput) secondaryInput.value = this.secondaryColor;
    },

    setColors: function() {
        this.mainColor = document.getElementById('main-color').value;
        this.secondaryColor = document.getElementById('secondary-color').value;

        localStorage.setItem('nd_main_color', this.mainColor);
        localStorage.setItem('nd_sec_color', this.secondaryColor);

        document.documentElement.style.setProperty('--player-main', this.mainColor);
        document.documentElement.style.setProperty('--player-sec', this.secondaryColor);
    },

    reset: function() {
        // Player starts further away from the first obstacle (X=20, was X=0)
        this.x = 20 * CFG.tile; 
        this.y=0; this.dy=0; this.angle=0; 
        this.mode='cube'; this.onGround=true;
    },

    update: function() {
        // Mode Physics (Same as V6)
        if(this.mode === 'cube') {
            this.dy += CFG.g;
            if(this.onGround) {
                let r = Math.round(this.angle/(Math.PI/2))*(Math.PI/2);
                this.angle += (r-this.angle)*0.25; 
            } else {
                this.angle += 0.18;
            }
        } else if (this.mode === 'ship') {
            if(Input.held) this.dy -= 0.6; 
            else this.dy += 0.5; 
            this.angle = this.dy * 0.15;
        } else if (this.mode === 'ufo') {
            this.dy += CFG.g;
            this.angle += (0-this.angle)*0.1;
        }

        // Terminal Velocity
        if(this.dy > CFG.term) this.dy = CFG.term;
        if(this.mode === 'ship' && this.dy < -10) this.dy = -10;

        // Move X
        this.x += this.dx;
        this.checkCol(true);

        // Move Y
        this.y += this.dy;
        this.onGround = false;

        // Floor / Ceiling Cap (Max Height Check)
        if(this.y > 0) { 
            this.y = 0; 
            this.dy = 0; 
            this.onGround = true; 
            if(this.mode==='ship'||this.mode==='ufo') this.dy = -4; 
        }
        if(this.y < CFG.maxHeight) { 
            this.y = CFG.maxHeight;
            this.dy = 0;
        } 

        this.checkCol(false);
    },

    checkCol: function(isX) {
        // Hitbox
        let l=this.x+5, r=this.x+this.w-5, t=this.y-this.h+5, b=this.y-5;

        Game.level.forEach(o => {
            if(Math.abs(o.x*CFG.tile - this.x) > 100) return; 

            let ox = o.x*CFG.tile, oy = -(o.y*CFG.tile);
            let ol = ox, or = ox+CFG.tile, ot = oy-CFG.tile, ob = oy;

            // AABB
            if(r>ol && l<or && b>ot && t<ob) {
                if(o.t===2) Game.crash();
                else if(o.t===99) Game.win();
                else if(o.t===3) {} 
                else if(o.t===7 && this.dy > 0) { // Pad
                     this.dy = -22; 
                     this.onGround=false; 
                     AUDIO.pad();
                }
                else if(o.t===4) this.setMode('ship');
                else if(o.t===5) this.setMode('ufo');
                else if(o.t===6) this.setMode('cube');
                else if(o.t===1) { // Block
                    if(isX) { 
                        Game.crash(); // Horizontal hit is death
                    }
                    else {
                        if(this.dy > 0) { // Landing (Floor)
                            this.y = ob+this.h-10; 
                            this.dy = 0; 
                            this.onGround = true;
                        } else { // Head hit (Ceiling)
                            this.y = ot+10;
                            this.dy = 0;
                        }
                    }
                }
            }
        });
    },

    jump: function() {
        // Check Orbs
        let hitOrb = false;
        let l=this.x, r=this.x+this.w, t=this.y-this.h, b=this.y;
        Game.level.forEach(o => {
            if(o.t===3) {
                let ox=o.x*CFG.tile, oy=-(o.y*CFG.tile)-CFG.tile;
                if(r>ox-20 && l<ox+70 && b>oy-20 && t<oy+70) {
                    this.dy = -CFG.jmp * 0.9;
                    this.onGround = false;
                    hitOrb=true;
                    AUDIO.orb();
                }
            }
        });
        if(hitOrb) return;

        if(this.mode === 'cube' && this.onGround) {
            this.dy = -CFG.jmp;
            this.onGround = false;
            AUDIO.jump();
        } else if(this.mode === 'ufo') {
            this.dy = -CFG.jmp * 0.7;
            AUDIO.jump();
        }
    },

    setMode: function(m) {
        if(this.mode === m) return;
        this.mode = m; 
        AUDIO.pad();
        const msg = document.getElementById('msg');
        msg.innerText = m; msg.style.opacity = 0.5;
        setTimeout(()=>msg.style.opacity=0, 1000);
    },

    draw: function(ctx, camY) {
        ctx.save();
        let drawY = this.y + camY; 
        ctx.translate(this.x - Game.camX + this.w/2, drawY - this.h/2);
        ctx.rotate(this.angle);
        
        // Draw the square using customizable colors
        ctx.fillStyle = this.mainColor;
        
        // Dynamic color for ship/ufo modes
        if(this.mode === 'ship') ctx.fillStyle = '#0f0';
        if(this.mode === 'ufo') ctx.fillStyle = '#fa0';
        
        ctx.fillRect(-20,-20,40,40);
        
        // Inner face uses the secondary color
        ctx.fillStyle = this.secondaryColor; 
        ctx.fillRect(-10,-10,20,20);
        ctx.fillStyle = '#fff'; ctx.fillRect(-5,-5,10,10);
        
        ctx.restore();
    }
};

const UI = {
    hide: () => document.querySelectorAll('.ui-layer').forEach(e => e.classList.replace('visible','hidden')),
    show: (id) => { 
        UI.hide();
        document.getElementById(id).classList.replace('hidden','visible');
    },
    home: () => { Game.state='menu'; UI.show('menu-main'); document.getElementById('hud').style.display='none'; },
    showLevels: () => {
        const grid = document.getElementById('lvl-grid');
        grid.innerHTML = '';
        for(let i=0; i<10; i++) {
            let b = document.createElement('div');
            b.className = 'lvl-btn';
            b.innerText = i+1;
            if(i+1 > unlocked) {
                b.classList.add('locked');
            } else {
                b.onclick = () => Game.loadLevel(i);
            }
            grid.appendChild(b);
        }
        UI.show('menu-levels');
    },
    showEditor: () => {
        Game.state = 'editor';
        Game.level = [];
        Game.camX = 0;
        UI.show('editor-overlay');
        let d = localStorage.getItem('nd_custom');
        if(d) Game.level = JSON.parse(d);
    }
};

const Editor = {
    tool: 1,
    test: function() { localStorage.setItem('nd_custom', JSON.stringify(Game.level)); Game.loadCustom(); },
    save: function() { localStorage.setItem('nd_custom', JSON.stringify(Game.level)); alert('Saved!'); },
};

// --- INPUT ---
const Input = { held: false };
const action = () => { Input.held=true; AUDIO.init(); if(Game.state==='game') Player.jump(); };
const release = () => { Input.held=false; };

window.onkeydown = (e) => { 
    if(e.repeat) return; 
    
    // Action (Jump/Thrust)
    if(e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault(); 
        action();
    }
    // Reset
    else if (e.code === 'KeyR') {
        Game.retry();
    }
    // Menu
    else if (e.code === 'Escape' && Game.state==='game') {
        UI.home();
    }
};

window.onkeyup = (e) => { 
    if(e.code === 'Space' || e.code === 'ArrowUp') {
        release();
    }
};

window.onmousedown = (e) => {
    if(Game.state === 'editor') {
        // Calculate grid position for placing blocks
        let mx = e.clientX + Game.camX;
        let gy = Math.floor(-(e.clientY - (Game.canvas.height - 150))/CFG.tile); 
        let gx = Math.floor(mx/CFG.tile);

        if(gy>=0) {
            Game.level = Game.level.filter(o=>!(o.x===gx && o.y===gy));
            if(Editor.tool!==0) Game.level.push({t:Editor.tool, x:gx, y:gy});
        }
    } else {
        action();
    }
};
window.onmouseup = () => release();

Game.init();
</script>
</body>
</html>
