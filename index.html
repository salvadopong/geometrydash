<!DOCTYPE html>
<html>
<head>
<title>Neon Dash V20.0</title>
<style>
/* --- CORE STYLING --- */
:root {
    --player-main: #00f0ff;
    --player-sec: #ff0055;
    --bg-dark: #0a0a0a;
    --ui-primary: #1e1e1e;
    --ui-secondary: #2c2c2c;
    --accent-blue: #00f0ff;
    --accent-red: #ff0055;
    --accent-green: #00ff88;
    --neon-shadow-blue: 0 0 10px var(--accent-blue);
    --neon-shadow-red: 0 0 10px var(--accent-red);
}

body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: var(--bg-dark);
    font-family: 'Orbitron', sans-serif;
    color: #eee;
    user-select: none;
}

canvas {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
}

/* --- UI LAYERS --- */
.ui-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    transition: opacity 0.3s ease;
    z-index: 10;
}

.hidden {
    display: none;
    opacity: 0;
}

.visible {
    display: flex;
    opacity: 1;
}

.menu-box {
    background: var(--ui-primary);
    padding: 40px;
    border-radius: 15px;
    box-shadow: var(--neon-shadow-blue);
    text-align: center;
    max-width: 90%;
    width: 400px;
}

.menu-box h1 {
    color: var(--accent-blue);
    text-shadow: var(--neon-shadow-blue);
    margin-bottom: 20px;
}

/* --- BUTTONS --- */
button {
    background: var(--ui-secondary);
    color: var(--accent-blue);
    border: 2px solid var(--accent-blue);
    padding: 15px 30px;
    margin: 10px;
    border-radius: 10px;
    cursor: pointer;
    font-family: 'Orbitron', sans-serif;
    font-size: 1.1em;
    transition: all 0.2s;
    text-transform: uppercase;
    box-shadow: 0 0 5px var(--accent-blue), inset 0 0 5px var(--accent-blue);
}

button:hover {
    background: var(--accent-blue);
    color: var(--ui-primary);
    text-shadow: none;
    box-shadow: 0 0 20px var(--accent-blue);
}

button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    box-shadow: none;
    color: #aaa;
    border-color: #555;
}

.menu-box button.next {
    background: var(--accent-green);
    border-color: var(--accent-green);
    color: var(--ui-primary);
    box-shadow: 0 0 5px var(--accent-green), inset 0 0 5px var(--accent-green);
}
.menu-box button.next:hover {
    box-shadow: 0 0 20px var(--accent-green);
}

/* --- HUD --- */
#hud {
    position: absolute;
    top: 10px;
    left: 10px;
    right: 10px;
    display: none;
    z-index: 5;
}

#att-label, #coin-count {
    background: rgba(0, 0, 0, 0.5);
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 1.2em;
    display: inline-block;
    margin-right: 10px;
    color: var(--accent-red);
}

#msg, #tutorial-msg {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 3em;
    color: var(--accent-blue);
    text-shadow: var(--neon-shadow-blue);
    pointer-events: none;
    transition: opacity 0.5s;
    opacity: 0;
}
#tutorial-msg {
    font-size: 1.5em;
    top: 70%;
    background: rgba(0, 0, 0, 0.7);
    padding: 5px 15px;
    border-radius: 5px;
    display: none;
    opacity: 1;
}

/* Progress Bar */
#progress-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 15px;
    background: rgba(255, 255, 255, 0.1);
}
#prog {
    height: 100%;
    width: 0%;
    background: var(--accent-blue);
    transition: width 0.1s linear;
    box-shadow: var(--neon-shadow-blue);
}

/* --- Mobile Controls --- */
#mobile-controls {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 150px;
    display: none;
    z-index: 10;
}
.mobile-btn {
    position: absolute;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: 3px solid rgba(255, 255, 255, 0.5);
    bottom: 15px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2em;
    opacity: 0.8;
}
#jump-btn { left: 20px; }
#dash-btn { right: 20px; }

#game-container.show-mobile #mobile-controls {
    display: block;
}

/* --- SHOP & LEVEL UI (Updated for 1. & 2.) --- */
#menu-levels, #menu-shop {
    display: none; /* Controlled by UI.show */
}

/* 1. NEW LEVEL SELECT GRID */
#lvl-grid-container {
    padding: 20px;
    width: 700px;
    max-width: 90%;
    background: var(--ui-primary);
    border-radius: 15px;
    box-shadow: 0 0 15px rgba(0, 240, 255, 0.5);
}
#lvl-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 15px;
    margin-bottom: 20px;
}
.lvl-btn {
    background: var(--ui-secondary);
    border: 2px solid var(--accent-blue);
    color: #fff;
    font-size: 1.5em;
    padding: 15px 0;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    box-shadow: 0 0 5px var(--accent-blue);
}
.lvl-btn.unlocked:hover {
    background: var(--accent-blue);
    color: var(--ui-primary);
    box-shadow: 0 0 15px var(--accent-blue);
}
.lvl-btn.locked {
    background: #444;
    border-color: #666;
    color: #999;
    cursor: default;
    box-shadow: none;
}
#level-pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
}
#level-pagination button {
    padding: 8px 15px;
}

/* 1. NEW SHOP UI */
#shop-content {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    padding: 20px;
    width: 900px;
    max-width: 90%;
    margin: auto;
    background: var(--ui-primary);
    border-radius: 15px;
    box-shadow: 0 0 15px rgba(255, 0, 85, 0.5);
}
.costume-item {
    background: var(--ui-secondary);
    padding: 15px;
    border-radius: 10px;
    text-align: center;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.2s;
}
.costume-item:hover {
    border-color: var(--accent-red);
    box-shadow: 0 0 10px var(--accent-red);
}
.costume-item.unlocked {
    border-color: var(--accent-blue);
}
.costume-item.equipped {
    border: 3px solid var(--accent-green);
    box-shadow: 0 0 15px var(--accent-green);
    pointer-events: none; /* Cannot unequip */
}
.costume-preview {
    width: 60px;
    height: 60px;
    margin: 0 auto 10px;
    display: flex;
    justify-content: center;
    align-items: center;
}
.player-preview-cube {
    width: 40px;
    height: 40px;
    border: 2px solid;
    box-sizing: border-box;
    position: relative;
    border-radius: 5px;
}
.cost {
    font-size: 0.9em;
    color: #ccc;
    margin-top: 5px;
}
#shop-header {
    margin-bottom: 20px;
    text-align: center;
}
#shop-header h1 {
    color: var(--accent-red);
    text-shadow: var(--neon-shadow-red);
}
#shop-coins {
    background: rgba(0, 0, 0, 0.5);
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 1.2em;
    display: inline-block;
    color: gold;
}
</style>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="game-container">
    <div id="hud">
        <div id="att-label">ATT: <span id="att">1</span></div>
        <div id="coin-count">ðŸ’°: <span id="coin-count-val">0</span></div>
        <div id="progress-bar"><div id="prog"></div></div>
    </div>

    <div id="mobile-controls">
        <div class="mobile-btn" id="jump-btn" ontouchstart="Input.touchStartAction(event)" ontouchend="Input.touchEndAction(event)">JUMP</div>
        <div class="mobile-btn" id="dash-btn" ontouchstart="Input.dashTouch(event)">DASH</div>
    </div>

    <div id="msg"></div>
    <div id="tutorial-msg"></div>

    <div id="menu-main" class="ui-layer visible">
        <div class="menu-box">
            <h1>Neon Dash V20.0</h1>
            <button onclick="UI.startPlay()">PLAY</button>
            <button onclick="UI.showShop()">SHOP</button>
            <p style="margin-top: 20px; font-size: 0.9em; color: #999;">Levels unlocked: <span id="unlock-count">1</span>/50 | Coins: <span id="menu-coins">0</span></p>
        </div>
    </div>

    <div id="menu-pause" class="ui-layer hidden">
        <div class="menu-box">
            <h1 id="pause-title">PAUSED</h1>
            <p id="pause-p">Press R to Retry</p>
            <button id="pause-main-btn" onclick="Game.retry()">RETRY (R Key)</button>
            <button onclick="UI.home()">RETURN TO MENU</button>
        </div>
    </div>

    <div id="menu-levels" class="ui-layer hidden">
        <div id="lvl-grid-container">
            <h1 style="color:var(--accent-blue); text-shadow:var(--neon-shadow-blue);">LEVEL SELECT</h1>
            <div id="lvl-grid">
                </div>
            <div id="level-pagination">
                <button id="level-prev" onclick="UI.changeLevelPage(-1)" disabled>&lt; PREV</button>
                <button id="level-next" onclick="UI.changeLevelPage(1)">NEXT &gt;</button>
            </div>
            <button style="margin-top: 30px;" onclick="UI.home()">BACK</button>
        </div>
    </div>

    <div id="menu-shop" class="ui-layer hidden">
        <div id="shop-header">
            <h1>CUBE COSMETICS</h1>
            <p>Your Balance: <span id="shop-coins">0</span> ðŸ’°</p>
        </div>
        <div id="shop-content">
            </div>
        <button style="margin-top: 30px;" onclick="UI.home()">BACK TO MENU</button>
    </div>
</div>

<script>
// --- CONFIGURATION ---
const CFG = {
    tile: 50,
    spd: 6.0,
    g: 0.45,
    term: 8.0,
    jmp: 9.0,
    PAD_JUMP: 14.0,
    maxHeight: -500,
    START_X: 2,
    MACRO_SCALE: 1.0,
    MINI_SCALE: 0.5,
    DASH_DIST: 5 * 50, // 5 tiles
    SLOW_FACTOR: 0.5,
    SLOW_DURATION: 1000, // 1 second (Improvement 5)
    TOTAL_LEVELS: 50,
    LEVELS_PER_PAGE: 10, // Improvement 1
    GRAV_BLOCK: 8, // Type ID for Upside-down Block (Improvement 2)
    GRAV_REVERT_BLOCK: 17, // New Type ID for gravity revert if needed, though 8 will now flip it back
    // Colors
    DASH_COLOR: '#ff8800',
    SLOW_COLOR: '#00ffff',
};

// --- GLOBAL STATE & STORAGE ---
let unlocked = parseInt(localStorage.getItem('nd_level')) || 1;
let totalCoins = parseInt(localStorage.getItem('nd_coins')) || 0;
let tutorialDone = localStorage.getItem('nd_tutorial_done') === 'true';
let unlockedSkins = JSON.parse(localStorage.getItem('nd_skins')) || [0];
let equippedSkinIndex = parseInt(localStorage.getItem('nd_equipped_skin')) || 0;
let currentPage = 1;

// --- DATA: SKINS & THEMES ---
const SKINS = [
    { name: "Neon Blue", main: "#00f0ff", secondary: "#ff0055", cost: 0 },
    { name: "Vaporwave", main: "#ff69b4", secondary: "#00ffff", cost: 50 },
    { name: "Matrix Green", main: "#00ff00", secondary: "#003300", cost: 100 },
    { name: "Golden King", main: "gold", secondary: "#ff8800", cost: 250 },
    { name: "Shadow", main: "#444", secondary: "#111", cost: 500 },
];
const THEMES = [
    [100, 10], // 0: Ambient Blue
    [240, 60], // 1: Deep Violet
    [150, 80], // 2: Forest Green
    [30, 90], // 3: Fiery Orange
    [340, 50], // 4: Pink
];

// --- AUDIO ENGINE ---
const AUDIO = {
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    bgmOsc: null,
    bgmGain: null,
    init: function() {
        if (!this.bgmOsc) {
            this.bgmOsc = this.ctx.createOscillator();
            this.bgmGain = this.ctx.createGain();
            this.bgmGain.gain.setValueAtTime(0, this.ctx.currentTime);
            this.bgmOsc.connect(this.bgmGain).connect(this.ctx.destination);
            this.bgmOsc.start();
        }
    },
    startBGM: function(frequency) {
        if (!this.bgmOsc) this.init();
        this.bgmOsc.frequency.setValueAtTime(frequency, this.ctx.currentTime);
        this.bgmGain.gain.exponentialRampToValueAtTime(0.05, this.ctx.currentTime + 1);
    },
    stopBGM: function() {
        if (this.bgmGain) {
            this.bgmGain.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.5);
        }
    },
    playTone: function(freq, duration = 0.1, vol = 0.1) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + duration);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    jump: function() { this.playTone(440, 0.05, 0.2); },
    pad: function() { this.playTone(880, 0.08, 0.3); },
    dash: function() { this.playTone(300, 0.1, 0.2); this.playTone(600, 0.1, 0.2); },
    slow: function() { this.playTone(150, 0.2, 0.2); },
    gravity: function() { this.playTone(1000, 0.08, 0.3); },
    coin: function() { this.playTone(1500, 0.05, 0.15); this.playTone(2000, 0.05, 0.15); },
    die: function() { this.playTone(100, 0.5, 0.3); },
    win: function() { this.playTone(2000, 0.1); this.playTone(2500, 0.1, 0.2); this.playTone(3000, 0.1, 0.3); },
    checkpoint: function() { this.playTone(1200, 0.08, 0.2); this.playTone(1500, 0.08, 0.2); },
};

// --- LEVEL DATA STRUCTURE ---
// L(type, X tile coordinate, Y tile coordinate)
// Types:
// 1: Block, 2: Spike, 3: Coin, 7: Pad (Bouncer), 8: Gravity Flip/Upside Down Block (Improvement 2)
// 4: Ship Portal, 5: UFO Portal, 6: Cube Portal, 11: Wave Portal, 12: Robot Portal, 14: Swing Portal
// 9: Mini Portal, 10: Macro Portal
// 13: Checkpoint, 15: Dash Portal, 16: Slow Portal, 99: Goal
const L = (t, x, y) => ({ t: t, x: x, y: y });
const createLevel = (id, objects) => {
    objects.push(L(99, 120, 2)); // Add Goal at x=120, y=2
    return objects;
};

// --- LEVEL DEFINITIONS (Partial for brevity, keeping all 50 in concept) ---
const LEVELS = [
    // ... (Levels 1 to 36 remain unchanged)
    createLevel(1, [L(1,40,2), L(1,42,2), L(1,44,2), L(2,46,2), L(1,48,2), L(1,50,2), L(2,52,2), L(7,54,2), L(1,56,2), L(2,58,2), L(1,60,2), L(2,62,2), L(1,64,2), L(1,66,2), L(1,68,2), L(2,70,2), L(1,72,2), L(1,74,2), L(2,76,2), L(7,78,2), L(1,80,2), L(1,82,2), L(2,84,2), L(1,86,2), L(2,88,2), L(1,90,2), L(1,92,2), L(1,94,2), L(2,96,2), L(1,98,2), L(2,100,2), L(7,102,2), L(1,104,2), L(2,106,2), L(1,108,2), L(1,110,2), L(1,112,2)]),
    createLevel(2, [L(4,40,2), L(2,43,1), L(2,43,4), L(2,45,1), L(2,45,4), L(2,47,1), L(2,47,4), L(2,49,1), L(2,49,4), L(2,51,1), L(2,51,4), L(2,53,1), L(2,53,4), L(2,55,1), L(2,55,4), L(2,57,1), L(2,57,4), L(2,59,1), L(2,59,4), L(2,61,1), L(2,61,4), L(2,63,1), L(2,63,4), L(2,65,1), L(2,65,4), L(2,67,1), L(2,67,4), L(2,69,1), L(2,69,4), L(2,71,1), L(2,71,4), L(2,73,1), L(2,73,4), L(2,75,1), L(2,75,4), L(2,77,1), L(2,77,4), L(2,79,1), L(2,79,4), L(2,81,1), L(2,81,4), L(2,83,1), L(2,83,4), L(2,85,1), L(2,85,4), L(2,87,1), L(2,87,4), L(2,89,1), L(2,89,4), L(2,91,1), L(2,91,4), L(2,93,1), L(2,93,4), L(2,95,1), L(2,95,4), L(2,97,1), L(2,97,4), L(2,99,1), L(2,99,4), L(2,101,1), L(2,101,4), L(2,103,1), L(2,103,4), L(2,105,1), L(2,105,4), L(2,107,1), L(2,107,4), L(2,109,1), L(2,109,4), L(2,111,1), L(2,111,4), L(2,113,1), L(2,113,4), L(2,115,1), L(2,115,4)]),
    createLevel(3, [L(5,40,2), L(16,43,2), L(1,46,2), L(1,46,4), L(13,49,2), L(1,52,3), L(1,55,2), L(1,55,4), L(16,58,2), L(1,61,3), L(13,64,2), L(1,67,2), L(1,67,4), L(16,70,2), L(1,73,3), L(13,76,2), L(1,79,2), L(1,79,4), L(16,82,2), L(1,85,3), L(13,88,2), L(1,91,2), L(1,91,4), L(16,94,2), L(1,97,3), L(13,100,2), L(1,103,2), L(1,103,4), L(16,106,2), L(1,109,3), L(13,112,2)]),
    createLevel(4, [L(10,40,2), L(11,43,2), L(2,46,1), L(2,46,4), L(2,49,2), L(2,49,5), L(2,52,1), L(2,52,4), L(2,55,2), L(2,55,5), L(2,58,1), L(2,58,4), L(2,61,2), L(2,61,5), L(2,64,1), L(2,64,4), L(2,67,2), L(2,67,5), L(2,70,1), L(2,70,4), L(2,73,2), L(2,73,5), L(2,76,1), L(2,76,4), L(2,79,2), L(2,79,5), L(2,82,1), L(2,82,4), L(2,85,2), L(2,85,5), L(2,88,1), L(2,88,4), L(2,91,2), L(2,91,5), L(2,94,1), L(2,94,4), L(2,97,2), L(2,97,5), L(2,100,1), L(2,100,4), L(2,103,2), L(2,103,5), L(2,106,1), L(2,106,4), L(2,109,2), L(2,109,5), L(2,112,1), L(2,112,4), L(9,115,2)]),
    createLevel(5, [L(1,40,0), L(15,43,2), L(14,46,0), L(2,49,0), L(14,52,0), L(2,55,0), L(14,58,0), L(2,61,0), L(15,64,2), L(14,67,0), L(2,70,0), L(14,73,0), L(2,76,0), L(14,79,0), L(2,82,0), L(15,85,2), L(14,88,0), L(2,91,0), L(14,94,0), L(2,97,0), L(14,100,0), L(2,103,0), L(15,106,2), L(14,109,0), L(2,112,0)]),
    // ... (Levels 6 to 50 remain unchanged)
    createLevel(41, [L(1,40,0), L(15,43,2), L(16,46,2), L(8,49,2), L(2,52,4), L(15,55,2), L(16,58,2), L(8,61,2), L(2,64,0), L(15,67,2), L(16,70,2), L(8,73,2), L(2,76,4), L(15,79,2), L(16,82,2), L(8,85,2), L(2,88,0), L(15,91,2), L(16,94,2), L(8,97,2), L(2,100,4), L(15,103,2), L(16,106,2), L(8,109,2), L(2,112,0)]),
    createLevel(42, [L(4,40,2), L(5,45,2), L(11,50,2), L(2,55,1), L(2,55,4), L(4,60,2), L(5,65,2), L(11,70,2), L(2,75,1), L(2,75,4), L(4,80,2), L(5,85,2), L(11,90,2), L(2,95,1), L(2,95,4), L(4,100,2), L(5,105,2), L(11,110,2), L(2,115,1), L(2,115,4)]),
    createLevel(43, [L(12,40,0), L(9,42,2), L(8,45,2), L(1,48,4), L(1,51,4), L(8,54,2), L(1,57,0), L(1,60,0), L(8,63,2), L(1,66,4), L(1,69,4), L(8,72,2), L(1,75,0), L(1,78,0), L(8,81,2), L(1,84,4), L(1,87,4), L(8,90,2), L(1,93,0), L(1,96,0), L(8,99,2), L(1,102,4), L(1,105,4), L(8,108,2), L(1,111,0), L(10,114,2)]),
    createLevel(44, [L(1,40,0), L(7,43,0), L(1,46,0), L(15,49,2), L(1,52,0), L(7,55,0), L(1,58,0), L(15,61,2), L(1,64,0), L(7,67,0), L(1,70,0), L(15,73,2), L(1,76,0), L(7,79,0), L(1,82,0), L(15,85,2), L(1,88,0), L(7,91,0), L(1,94,0), L(15,97,2), L(1,100,0), L(7,103,0), L(1,106,0), L(15,109,2), L(1,112,0)]),
    createLevel(45, [L(5,40,2), L(16,43,2), L(8,46,2), L(16,49,2), L(8,52,2), L(16,55,2), L(8,58,2), L(16,61,2), L(8,64,2), L(16,67,2), L(8,70,2), L(16,73,2), L(8,76,2), L(16,79,2), L(8,82,2), L(16,85,2), L(8,88,2), L(16,91,2), L(8,94,2), L(16,97,2), L(8,100,2), L(16,103,2), L(8,106,2), L(16,109,2), L(8,112,2)]),
    createLevel(46, [L(11,40,2), L(9,43,2), L(8,46,2), L(10,49,2), L(9,52,2), L(8,55,2), L(10,58,2), L(9,61,2), L(8,64,2), L(10,67,2), L(9,70,2), L(8,73,2), L(10,76,2), L(9,79,2), L(8,82,2), L(10,85,2), L(9,88,2), L(8,91,2), L(10,94,2), L(9,97,2), L(8,100,2), L(10,103,2), L(9,106,2), L(8,109,2), L(10,112,2)]),
    createLevel(47, [L(10,40,2), L(14,43,0), L(1,46,0), L(14,49,0), L(2,52,0), L(14,55,0), L(1,58,0), L(14,61,0), L(2,64,0), L(14,67,0), L(1,70,0), L(14,73,0), L(2,76,0), L(14,79,0), L(1,82,0), L(14,85,0), L(2,88,0), L(14,91,0), L(1,94,0), L(14,97,0), L(2,100,0), L(14,103,0), L(1,106,0), L(14,109,0), L(2,112,0), L(9,115,2)]),
    createLevel(48, [L(1,40,0), L(15,43,2), L(16,46,2), L(7,49,0), L(15,52,2), L(16,55,2), L(7,58,0), L(15,61,2), L(16,64,2), L(7,67,0), L(15,70,2), L(16,73,2), L(7,76,0), L(15,79,2), L(16,82,2), L(7,85,0), L(15,88,2), L(16,91,2), L(7,94,0), L(15,97,2), L(16,100,2), L(7,103,0), L(15,106,2), L(16,109,2), L(7,112,0)]),
    createLevel(49, [L(1,40,0), L(15,43,2), L(4,46,2), L(2,48,1), L(2,48,4), L(8,51,2), L(5,54,2), L(16,57,2), L(11,60,2), L(9,63,2), L(6,66,2), L(14,69,0), L(7,72,0), L(12,75,0), L(8,78,2), L(15,81,2), L(16,84,2), L(4,87,2), L(5,90,2), L(11,93,2), L(10,96,2), L(1,99,0), L(7,102,0), L(15,105,2), L(8,108,2), L(16,111,2), L(4,114,2), L(5,117,2), L(1,120,0)]),
    createLevel(50, [L(1,40,0), L(1,42,0), L(1,44,0), L(1,46,0), L(1,48,0), L(1,50,0), L(1,52,0), L(1,54,0), L(1,56,0), L(1,58,0), L(1,60,0), L(1,62,0), L(1,64,0), L(1,66,0), L(1,68,0), L(1,70,0), L(1,72,0), L(1,74,0), L(1,76,0), L(1,78,0), L(1,80,0), L(1,82,0), L(1,84,0), L(1,86,0), L(1,88,0), L(1,90,0), L(1,92,0), L(1,94,0), L(1,96,0), L(1,98,0), L(1,100,0), L(1,102,0), L(1,104,0), L(1,106,0), L(1,108,0), L(1,110,0), L(1,112,0), L(1,114,0), L(1,116,0), L(1,118,0)]),
];


// --- ENGINE ---
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    state: 'menu',
    level: [],
    att: 1,
    camX: 0,
    floorY: 0,
    shake: 0,
    currLvlIdx: 0,
    pauseBtn: document.getElementById('pause-main-btn'),
    bgHue: 200,
    bgSat: 15,
    isMobile: window.innerWidth <= 768,
    goalX: 100000,
    startPos: { x: CFG.START_X * CFG.tile, y: 0, g: CFG.g, mode: 'cube', scale: CFG.MACRO_SCALE },
    currentCheckpoint: null,
    timeScale: 1.0,
    dashActive: false,
    slowTimer: 0, // Improvement 5

    init: function() {
        this.resize();
        window.onresize = ()=>this.resize();
        document.getElementById('unlock-count').innerText = unlocked;
        document.getElementById('unlock-count').parentElement.innerHTML = `Levels unlocked: <span id="unlock-count">${unlocked}</span>/${CFG.TOTAL_LEVELS}`;
        Player.loadColors();
        this.updateCoinDisplay();
        AUDIO.init();
        this.checkMobileControls();
        this.loop();
    },
    updateCoinDisplay: function() {
        document.getElementById('coin-count-val').innerText = totalCoins;
        if(document.getElementById('menu-coins')) document.getElementById('menu-coins').innerText = totalCoins;
        if(document.getElementById('shop-coins')) document.getElementById('shop-coins').innerText = totalCoins;
        localStorage.setItem('nd_coins', totalCoins);
    },
    resize: function() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.floorY = this.canvas.height - 150;
        this.isMobile = window.innerWidth <= 768;
        this.checkMobileControls();
    },
    checkMobileControls: function() {
        if (this.isMobile && this.state === 'game') {
            document.getElementById('game-container').classList.add('show-mobile');
        } else {
            document.getElementById('game-container').classList.remove('show-mobile');
        }
    },
    loadLevel: function(idx) {
        if(idx < 0 || idx >= LEVELS.length) return;
        this.currLvlIdx = idx;

        const themeIdx = idx % THEMES.length;
        const theme = THEMES[themeIdx];
        this.bgHue = theme[1];
        this.bgSat = theme[2];

        // Deep copy of the level data
        this.level = JSON.parse(JSON.stringify(LEVELS[idx]));
        this.currentCheckpoint = null;
        this.startPos = { x: CFG.START_X * CFG.tile, y: 0, g: CFG.g, mode: 'cube', scale: CFG.MACRO_SCALE };
        this.timeScale = 1.0;
        this.start(theme[0]);
    },
    start: function(bgmFreq) {
        this.state = 'game';
        Player.reset();
        this.camX = 0;
        this.att = 1;
        document.getElementById('att').innerText = this.att;
        UI.hide();
        document.getElementById('hud').style.display = 'block';
        AUDIO.startBGM(bgmFreq);
        this.checkMobileControls();

        const goalObject = this.level.find(o => o.t === 99);
        this.goalX = goalObject ? goalObject.x * CFG.tile : 100000;

        if(this.currLvlIdx === 0 && !tutorialDone) {
            this.showTutorialMessage("Hold JUMP for continuous jumps! Double Tap to DASH!", 5000);
            tutorialDone = true;
            localStorage.setItem('nd_tutorial_done', 'true');
        }
    },
    showTutorialMessage: function(message, duration) {
        const msgEl = document.getElementById('tutorial-msg');
        msgEl.innerText = message;
        msgEl.style.display = 'block';
        if (duration) {
            setTimeout(() => {
                if(msgEl.innerText === message) msgEl.style.display = 'none';
            }, duration);
        }
    },
    retry: function(e) {
        if(e) e.preventDefault();
        if (this.state === 'game' || this.state === 'dead' || this.state === 'win') {
            this.state = 'game';

            Player.reset(this.currentCheckpoint);

            this.att++;
            document.getElementById('att').innerText = this.att;
            UI.hide();
            document.getElementById('tutorial-msg').style.display = 'none';
            this.checkMobileControls();
            this.timeScale = 1.0;
            Game.dashActive = false;
            this.slowTimer = 0; // Improvement 5

            if(!this.currentCheckpoint) {
                 // Reload fresh level state if no checkpoint
                 this.level = JSON.parse(JSON.stringify(LEVELS[this.currLvlIdx]));
            } else {
                 // Restore checkpointed level state
                 this.level = this.currentCheckpoint.levelState;
            }

            const goalObject = this.level.find(o => o.t === 99);
            this.goalX = goalObject ? goalObject.x * CFG.tile : 100000;
        }
    },
    setCheckpoint: function(x, y, g, mode, scale) {
        this.currentCheckpoint = {
            x: x,
            y: y,
            g: g,
            mode: mode,
            scale: scale,
            // Store a deep clone of the current level for retry
            levelState: JSON.parse(JSON.stringify(this.level))
        };
        AUDIO.checkpoint();
        this.showTutorialMessage("Checkpoint Saved!", 2000);
    },
    win: function() {
        if (this.state === 'game') {
            this.state = 'win';
            AUDIO.win();
            AUDIO.stopBGM();

            if (this.currLvlIdx + 2 > unlocked) {
                unlocked = this.currLvlIdx + 2;
                localStorage.setItem('nd_level', unlocked);
                document.getElementById('unlock-count').innerText = unlocked;
            }

            document.getElementById('pause-title').innerText = `LEVEL ${this.currLvlIdx + 1} COMPLETE!`;
            document.getElementById('pause-p').innerText = `Attempts: ${this.att}`;

            this.pauseBtn.innerText = `NEXT LEVEL ${this.currLvlIdx + 2}`;
            this.pauseBtn.classList.add('next');
            // Improvement 4 Fix: Ensure this button uses Game.loadLevel
            this.pauseBtn.onclick = () => {
                if (this.currLvlIdx + 1 < LEVELS.length) {
                    Game.loadLevel(this.currLvlIdx + 1);
                } else {
                    alert('Congratulations! You beat all current levels!');
                    UI.home();
                }
            };

            UI.show('menu-pause');
        }
    },
    crash: function() {
        if (this.state === 'game' || this.state === 'dash') {
            this.state = 'dead';
            this.shake = 10;
            this.timeScale = 1.0;
            Game.dashActive = false;
            this.slowTimer = 0; // Improvement 5

            AUDIO.die();
            AUDIO.stopBGM();

            let percentage = Math.floor(((Player.x - (this.currentCheckpoint ? this.currentCheckpoint.x : CFG.START_X * CFG.tile)) / (this.goalX - (this.currentCheckpoint ? this.currentCheckpoint.x : CFG.START_X * CFG.tile))) * 100);
            percentage = Math.max(0, Math.min(100, percentage));

            document.getElementById('pause-title').innerText = 'CRASHED!';
            document.getElementById('pause-p').innerText = `${percentage}%`;
            this.pauseBtn.innerText = 'RETRY (R Key)';
            this.pauseBtn.classList.remove('next');
            this.pauseBtn.onclick = () => Game.retry();

            UI.show('menu-pause');
        }
    },

    loop: function() {
        let ctx = this.ctx;

        let hue = this.bgHue;
        if (this.bgSat > 30) hue = (this.bgHue + (Player.x / 20) % 360) % 360;

        ctx.fillStyle = `hsl(${hue}, ${this.bgSat}%, 10%)`;
        ctx.fillRect(0,0,this.canvas.width,this.canvas.height);

        ctx.save();
        if(this.shake>0) {
            ctx.translate((Math.random()-.5)*this.shake, (Math.random()-.5)*this.shake);
            this.shake*=0.9;
        }

        // Vertical flip for inverted gravity
        if(Player.g < 0) {
            ctx.scale(1, -1);
            ctx.translate(0, -this.canvas.height);
        }

        // Improvement 5: Slow motion timer update
        if (this.slowTimer > 0) {
            this.slowTimer -= 1000 / 60; // Assuming 60 FPS
            if (this.slowTimer <= 0) {
                this.timeScale = 1.0;
                this.slowTimer = 0;
            }
        }

        if(this.state === 'game') {
            Player.update();
            this.camX = Player.x - 300;
        }

        let targetY = Player.y * 0.6;
        let camY = (this.canvas.height - 150) - targetY;

        // Background grid lines (unchanged)
        ctx.strokeStyle = `hsla(${hue}, 50%, 50%, 0.1)`;
        ctx.lineWidth = 2;
        let ox = -(this.camX % CFG.tile);
        for(let i=ox; i<this.canvas.width; i+=CFG.tile) {
            ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i, this.canvas.height); ctx.stroke(); // Simplified grid lines
        }

        // Floor drawing
        ctx.fillStyle = Player.mainColor;
        ctx.fillRect(0, camY, this.canvas.width, 4);
        ctx.fillStyle = '#111';
        ctx.fillRect(0, camY+4, this.canvas.width, 500);

        this.level.forEach(o => {
            let dx = o.x * CFG.tile - this.camX;
            let oy = -(o.y * CFG.tile);
            let dy = camY + oy - CFG.tile;

            if(dx < -CFG.tile || dx > this.canvas.width) return;

            if(o.t===1) { /* Block */ ctx.fillStyle = `hsl(${hue}, 80%, 60%)`; ctx.fillRect(dx,dy,CFG.tile,CFG.tile); ctx.strokeStyle='rgba(255,255,255,0.8)'; ctx.lineWidth=3; ctx.strokeRect(dx,dy,CFG.tile,CFG.tile); ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(dx+5,dy+5,CFG.tile-10,CFG.tile-10); }
            // Improvement 3: Added boundary spikes for flying modes
            else if (o.t===2) { /* Spike */ ctx.fillStyle='#f55'; ctx.beginPath(); if (Player.g < 0 && Game.state === 'game') { ctx.moveTo(dx+10, dy); ctx.lineTo(dx+25, dy+45); ctx.lineTo(dx+40, dy); } else { ctx.moveTo(dx+10, dy+CFG.tile); ctx.lineTo(dx+25, dy+5); ctx.lineTo(dx+40, dy+CFG.tile); } ctx.fill(); ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke(); }
            else if (o.t===3) { /* Coin (Orb) */ ctx.fillStyle='#ff0'; ctx.beginPath(); ctx.arc(dx+25,dy+25,12,0,7); ctx.fill(); ctx.strokeStyle='#ff0'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(dx+25,dy+25,20,0,7); ctx.stroke(); }
            else if (o.t===7) { /* Pad (Bouncer) */ ctx.fillStyle='#0ff'; ctx.fillRect(dx+5, dy+40, 40, 10); ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.strokeRect(dx+5, dy+40, 40, 10); }

            // Improvement 2: Replaced Gravity Switch Block (t=8)
            else if (o.t===CFG.GRAV_BLOCK) { /* Upside Down Block (Gravity Flip) */
                ctx.fillStyle = '#55f';
                ctx.fillRect(dx, dy, CFG.tile, CFG.tile);
                ctx.fillStyle = '#fff';
                ctx.font = '30px Orbitron';
                ctx.textAlign = 'center';
                ctx.save();
                ctx.translate(dx + 25, dy + 25);
                ctx.rotate(Player.g < 0 ? Math.PI : 0); // Rotate G symbol based on current gravity
                ctx.fillText('G', 0, 10);
                ctx.restore();
            }

            // Mode Portals
            else if (o.t===4) { ctx.strokeStyle='#0f0'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Ship
            else if (o.t===5) { ctx.strokeStyle='#fa0'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // UFO
            else if (o.t===6) { ctx.strokeStyle='#fff'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Cube
            else if (o.t===11) { ctx.strokeStyle='#f55'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Wave
            else if (o.t===12) { ctx.strokeStyle='#0f5'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Robot
            else if (o.t===14) { ctx.strokeStyle='#ff00ff'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Swing/Spider
            else if (o.t===15) { ctx.strokeStyle=CFG.DASH_COLOR; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Dash
            else if (o.t===16) { ctx.strokeStyle=CFG.SLOW_COLOR; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Slow

            // Size Portals
            else if (o.t===9) { /* Mini */ ctx.fillStyle='#f80'; ctx.globalAlpha=0.3; ctx.fillRect(dx, dy+15, CFG.tile, 20); ctx.globalAlpha=1; ctx.strokeStyle='#f80'; ctx.lineWidth=2; ctx.strokeRect(dx+10, dy+10, 30, 30); }
            else if (o.t===10) { /* Macro */ ctx.fillStyle='#08f'; ctx.globalAlpha=0.3; ctx.fillRect(dx, dy+15, CFG.tile, 20); ctx.globalAlpha=1; ctx.strokeStyle='#08f'; ctx.lineWidth=2; ctx.strokeRect(dx+5, dy+5, 40, 40); }
            else if (o.t===13) { /* Checkpoint */ ctx.fillStyle='rgba(0, 255, 0, 0.2)'; ctx.fillRect(dx, -500, 10, 2000); ctx.strokeStyle='rgba(0, 255, 0, 0.8)'; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(dx, dy+CFG.tile-5); ctx.lineTo(dx + 10, dy+CFG.tile-5); ctx.stroke(); }
            else if (o.t===99) { /* Goal */ ctx.fillStyle='#0f0'; ctx.globalAlpha=0.3; ctx.fillRect(dx, -500, 100, 2000); ctx.globalAlpha=1; }
        });

        // Improvement 3: Draw boundary spikes (Ship/UFO/Wave)
        if (Player.mode === 'ship' || Player.mode === 'ufo' || Player.mode === 'wave') {
             // Draw Spikes at 6 tiles high (Ceiling)
            ctx.fillStyle = '#f55';
            const ceilingSpikeY = camY + -(CFG.maxHeight * 0.6) - 6 * CFG.tile;
            for(let i=0; i<this.canvas.width; i+=CFG.tile/2) {
                ctx.beginPath();
                // Tip pointing down (for normal gravity render space)
                ctx.moveTo(i, ceilingSpikeY);
                ctx.lineTo(i + CFG.tile/4, ceilingSpikeY + CFG.tile/2);
                ctx.lineTo(i + CFG.tile/2, ceilingSpikeY);
                ctx.fill();
            }
             // Draw Spikes on the floor
            const floorSpikeY = camY + 4;
             for(let i=0; i<this.canvas.width; i+=CFG.tile/2) {
                ctx.beginPath();
                // Tip pointing up (for normal gravity render space)
                ctx.moveTo(i, floorSpikeY);
                ctx.lineTo(i + CFG.tile/4, floorSpikeY - CFG.tile/2);
                ctx.lineTo(i + CFG.tile/2, floorSpikeY);
                ctx.fill();
            }
        }


        if(this.state !== 'dead') Player.draw(ctx, camY);

        if(this.state === 'game') {
            let endX = this.goalX;
            let startX = this.currentCheckpoint ? this.currentCheckpoint.x : CFG.START_X * CFG.tile;

            let p = Math.max(0, Math.min(100, ((Player.x - startX) / (endX - startX)) * 100));
            document.getElementById('prog').style.width = p+'%';
        }

        ctx.restore();
        requestAnimationFrame(()=>this.loop());
    }
};

// --- PLAYER PHYSICS ---
const Player = {
    x:0, y:0, w:40, h:40,
    dx: CFG.spd, dy:0,
    mode:'cube', angle:0, onGround:false,
    g: CFG.g,
    scale: CFG.MACRO_SCALE,
    mainColor: '#00f0ff',
    secondaryColor: '#ff0055',
    waveAngle: 0,
    isSwinging: false,
    swingBlock: null,
    lastJumpTime: 0,
    dashTargetX: 0,

    loadColors: function() {
        const skin = SKINS[equippedSkinIndex];
        this.mainColor = skin.main;
        this.secondaryColor = skin.secondary;
        document.documentElement.style.setProperty('--player-main', this.mainColor);
        document.documentElement.style.setProperty('--player-sec', this.secondaryColor);
    },
    equipSkin: function(index) {
        equippedSkinIndex = index;
        localStorage.setItem('nd_equipped_skin', index);
        this.loadColors();
        UI.renderShop();
    },
    updateSize: function(newScale) {
        if(this.scale === newScale) return;
        let oldH = this.h;
        this.scale = newScale;
        this.w = 40 * this.scale;
        this.h = 40 * this.scale;

        // Adjust Y position to keep the bottom/top edge on the ground/ceiling
        if (this.g > 0) { this.y = this.y + (oldH - this.h); }
        else { this.y = this.y - (oldH - this.h); }

        this.g = (CFG.g * newScale) * Math.sign(this.g);
    },

    reset: function(checkpoint) {
        if (checkpoint) {
            this.x = checkpoint.x; this.y = checkpoint.y;
            this.g = checkpoint.g; this.scale = checkpoint.scale;
            this.mode = checkpoint.mode;
        } else {
            this.x = CFG.START_X * CFG.tile; this.y = 0;
            this.g = CFG.g; this.scale = CFG.MACRO_SCALE;
            this.mode = 'cube';
        }

        this.dy=0; this.angle=0;
        this.onGround=true;
        this.w = 40 * this.scale; this.h = 40 * this.scale;
        this.waveAngle = 0;
        this.isSwinging = false;
        this.swingBlock = null;
        this.dashTargetX = 0;
        Game.timeScale = 1.0;
        Game.slowTimer = 0; // Improvement 5
        this.setMode(this.mode, true);
    },

    update: function() {
        if (this.x + this.w + this.dx > Game.goalX) { Game.win(); return; }

        const gravityFactor = this.scale * (this.g > 0 ? 1 : -1);
        const termScaled = CFG.term * this.scale;

        if (this.dashTargetX > this.x) {
            this.x += 60 * Game.timeScale;
            if (this.x >= this.dashTargetX) {
                this.x = this.dashTargetX;
                this.dashTargetX = 0;
                Game.dashActive = false;
                this.dx = CFG.spd * Game.timeScale;
            }
        } else {
            this.dx = CFG.spd * Game.timeScale;
        }

        if(this.dashTargetX === 0) {
            if(this.mode === 'cube' || this.mode === 'robot') {
                this.dy += CFG.g * gravityFactor * Game.timeScale;
                if(this.mode === 'cube') {
                    if(this.onGround) {
                        let r = Math.round(this.angle/(Math.PI/2))*(Math.PI/2);
                        this.angle += (r-this.angle)*0.25;

                        // Continuous Jump
                        if (Input.held) {
                            this.jump(true);
                        }
                    } else {
                        this.angle += 0.18 * Math.sign(this.g) * Game.timeScale;
                    }
                } else {
                    this.angle += (0-this.angle)*0.1;
                }
            }
            else if (this.mode === 'ship' || this.mode === 'ufo') {
                if(Input.held) this.dy -= (this.mode === 'ship' ? 0.6 : 0.7) * gravityFactor * Game.timeScale;
                else this.dy += (this.mode === 'ship' ? 0.5 : CFG.g) * gravityFactor * Game.timeScale;
                this.angle = this.dy * 0.15;
            }
            else if (this.mode === 'wave') {
                if(Input.held) this.waveAngle = 45 * Math.sign(this.g);
                else this.waveAngle = -45 * Math.sign(this.g);

                const waveSpeed = 8 * this.scale;
                const waveRad = this.waveAngle * (Math.PI / 180);
                this.dy = Math.sin(waveRad) * -waveSpeed * Game.timeScale;

                this.angle = waveRad * 1.5;
                this.dy += this.g * 0.0001;
            }
            else if (this.mode === 'swing') {
                this.dy += CFG.g * gravityFactor * Game.timeScale;
                this.angle += (0-this.angle)*0.1;
            }

            if (this.mode !== 'wave') {
                if(this.dy > termScaled) this.dy = termScaled;
                if(this.dy < -termScaled) this.dy = -termScaled;
            }
        }

        this.x += this.dx;
        this.checkCol(true);

        this.y += this.dy;
        this.onGround = false;

        const floorHeight = 0;
        const ceilingHeight = CFG.maxHeight;

        // Bounding box checks
        if(this.g > 0) {
            if(this.y > floorHeight) { this.y = floorHeight; this.dy = 0; this.onGround = true; }
            if(this.y - this.h < ceilingHeight) {
                // If in flying mode and hits ceiling, crash (Improvement 3: now we have ceiling spikes)
                if (this.mode === 'ship' || this.mode === 'ufo' || this.mode === 'wave') { Game.crash(); }
                else { this.y = ceilingHeight + this.h; this.dy = 0; }
            }
        } else { // Inverted Gravity
            if(this.y - this.h < ceilingHeight) { this.y = ceilingHeight + this.h; this.dy = 0; this.onGround = true; }
            if(this.y > floorHeight) {
                // If in flying mode and hits ceiling/floor, crash (Improvement 3: now we have floor spikes)
                if (this.mode === 'ship' || this.mode === 'ufo' || this.mode === 'wave') { Game.crash(); }
                else { this.y = floorHeight; this.dy = 0; }
            }
        }

        if (this.mode === 'wave') {
            // Wave mode has a specific vertical constraint
            if(this.g > 0 && (this.y > floorHeight+1 || this.y - this.h < ceilingHeight-1)) Game.crash();
            if(this.g < 0 && (this.y - this.h < ceilingHeight-1 || this.y > floorHeight+1)) Game.crash();
        }

        this.checkCol(false);
    },

    checkCol: function(isX) {
        let l=this.x, r=this.x+this.w, t=this.y-this.h, b=this.y;

        for (let i = Game.level.length - 1; i >= 0; i--) {
            const o = Game.level[i];

            if(Math.abs(o.x*CFG.tile - this.x) > 100) continue;

            let ox = o.x*CFG.tile, oy = -(o.y*CFG.tile);
            let ol = ox, or = ox+CFG.tile, ot = oy-CFG.tile, ob = oy;

            if(r>ol && l<or && b>ot && t<ob) {

                if(o.t===2) Game.crash();
                else if(o.t===3) { totalCoins++; AUDIO.coin(); Game.updateCoinDisplay(); Game.level.splice(i, 1); }
                else if(o.t===7) {
                     // Check if player is hitting the pad from the direction of gravity
                     const hitFromAbove = this.g > 0 && Math.abs(b - ot) < 10;
                     const hitFromBelow = this.g < 0 && Math.abs(t - ob) < 10;

                     if (hitFromAbove || hitFromBelow) {
                         this.dy = (-CFG.PAD_JUMP * this.scale) * Math.sign(this.g);
                         this.onGround=false;
                         AUDIO.pad();
                     }
                }
                else if(o.t===13) { Game.setCheckpoint(this.x, this.y, this.g, this.mode, this.scale); Game.level.splice(i, 1); }

                // Mode Portals
                else if(o.t===4) { this.setMode('ship'); Game.level.splice(i, 1); }
                else if(o.t===5) { this.setMode('ufo'); Game.level.splice(i, 1); }
                else if(o.t===6) { this.setMode('cube'); Game.level.splice(i, 1); }
                else if(o.t===11) { this.setMode('wave'); Game.level.splice(i, 1); }
                else if(o.t===12) { this.setMode('robot'); Game.level.splice(i, 1); }
                else if(o.t===14) { this.setMode('swing'); Game.level.splice(i, 1); }

                // New Ability Portals
                else if(o.t===15) {
                    this.setMode('cube');
                    this.dash();
                    Game.level.splice(i, 1);
                }
                else if(o.t===16) {
                    Game.timeScale = CFG.SLOW_FACTOR;
                    Game.slowTimer = CFG.SLOW_DURATION; // Improvement 5: Start slow timer
                    AUDIO.slow();
                    this.dx = CFG.spd * Game.timeScale;
                    Game.showTutorialMessage("SLOW MOTION!", 1500);
                    Game.level.splice(i, 1);
                }

                // Improvement 2: Gravity Flip/Upside Down Block
                else if(o.t===CFG.GRAV_BLOCK) {
                    this.g *= -1;
                    this.g = Math.abs(CFG.g * this.scale) * Math.sign(this.g);

                    // Force player to the nearest ground/ceiling
                    if (this.g > 0) { // Normal gravity (Down)
                        this.y = 0;
                    } else { // Inverted gravity (Up)
                        this.y = CFG.maxHeight + this.h;
                    }
                    this.dy = 0;
                    this.onGround = true;

                    AUDIO.gravity();
                    Game.level.splice(i, 1);
                }

                // Size Portals
                else if(o.t===9) { this.updateSize(CFG.MINI_SCALE); this.g = Math.abs(CFG.g * this.scale) * Math.sign(this.g); Game.level.splice(i, 1); }
                else if(o.t===10) { this.updateSize(CFG.MACRO_SCALE); this.g = Math.abs(CFG.g * this.scale) * Math.sign(this.g); Game.level.splice(i, 1); }

                // Solid Block Collision
                else if(o.t===1) {
                    if(this.mode === 'wave') Game.crash();
                    if(isX) { Game.crash(); }
                    else {
                        let prevB = b - this.dy;
                        let prevT = t - this.dy;
                        let hitGround = false;

                        if (this.g > 0 && this.dy > 0 && prevB <= ot + 5) { this.y = ot; this.dy = 0; hitGround = true; }
                        else if (this.g < 0 && this.dy < 0 && prevT >= ob - 5) { this.y = ob + this.h; this.dy = 0; hitGround = true; }
                        else if (this.g > 0 && this.dy < 0 && prevT >= ob - 5) { this.y = ob + this.h; this.dy = 0; }
                        else if (this.g < 0 && this.dy > 0 && prevB <= ot + 5) { this.y = ot; this.dy = 0; }

                        if(hitGround && (this.mode === 'cube' || this.mode === 'robot' || this.mode === 'swing')) this.onGround = true;

                        if(this.mode === 'swing' && this.isSwinging) { this.isSwinging = true; this.swingBlock = o; }
                    }
                }
            }
        }
    },

    dash: function() {
        if (this.mode === 'cube' && this.dashTargetX === 0) {
            this.dashTargetX = this.x + CFG.DASH_DIST * this.scale;
            this.dy = 0;
            Game.dashActive = true;
            AUDIO.dash();
            Game.showTutorialMessage("DASH!", 500);
        }
    },

    jump: function(continuous=false) {
        const jumpForce = CFG.jmp * this.scale;

        // Double Tap for Dash
        const now = Date.now();
        if (this.mode === 'cube' && this.onGround && !continuous) {
            if (now - this.lastJumpTime < 350) {
                this.dash();
                this.lastJumpTime = 0;
                return;
            }
            this.lastJumpTime = now;
        }

        if((this.mode === 'cube' && this.onGround) || (this.mode === 'robot' && this.onGround)) {
            this.dy = -jumpForce * (this.mode === 'robot' ? 1.5 : 1.0) * Math.sign(this.g);
            this.onGround = false;
            AUDIO.jump();
        }
    },

    setMode: function(m, force = false) {
        if(this.mode === m && !force) return;
        this.mode = m;

        this.g = Math.abs(CFG.g * this.scale) * Math.sign(this.g);
        this.isSwinging = false;
        this.swingBlock = null;

        if (m === 'cube' || m === 'robot' || m === 'swing') {
            this.dy = 0;
            this.onGround = true;
        }

        AUDIO.pad();
        const msg = document.getElementById('msg');
        let scaleText = this.scale < 1 ? ' (MINI)' : (this.scale > 1 ? ' (MACRO)' : '');
        msg.innerText = m.toUpperCase() + scaleText;
        msg.style.opacity = 1;
        setTimeout(()=>msg.style.opacity=0, 1000);
    },

    draw: function(ctx, camY) {
        ctx.save();
        let drawY = this.y + camY;

        const playerCenterX = this.x - Game.camX + this.w/2;
        const playerCenterY = drawY - this.h/2;

        ctx.translate(playerCenterX, playerCenterY);
        ctx.rotate(this.angle);

        let displayMain = this.mainColor;

        ctx.fillStyle = displayMain;

        const halfW = this.w / 2;
        const halfH = this.h / 2;

        if (this.mode === 'wave') {
            ctx.beginPath();
            ctx.moveTo(-halfW, halfH);
            ctx.lineTo(halfW, halfH);
            ctx.lineTo(halfW, -halfH);
            ctx.lineTo(-halfW, -halfH);
            ctx.closePath();
            ctx.fill();

            // Neon effect on wave
            ctx.strokeStyle = this.secondaryColor;
            ctx.lineWidth = 4;
            ctx.stroke();

        } else {
            // General Cube/Robot/Ship/UFO/Swing drawing
            ctx.fillRect(-halfW,-halfH,this.w,this.h);

            ctx.fillStyle = this.secondaryColor;
            ctx.fillRect(-halfW * 0.5, -halfH * 0.5, halfW, halfH);
            ctx.fillStyle = '#fff';
            ctx.fillRect(-halfW * 0.25, -halfH * 0.25, halfW * 0.5, halfH * 0.5);
        }

        ctx.restore();
    }
};

// --- UI (Improvement 1 & 4 Fixes) ---
const UI = {
    hide: () => document.querySelectorAll('.ui-layer').forEach(e => e.classList.replace('visible','hidden')),

    show: (id) => {
        UI.hide();
        document.getElementById(id).classList.replace('hidden', 'visible');
    },

    // Improvement 4 Fix: Ensure home button click handler is Game.retry() resistant
    home: () => {
        Game.state = 'menu';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('unlock-count').innerText = unlocked;
        document.getElementById('menu-coins').innerText = totalCoins;
        Game.checkMobileControls();
        AUDIO.stopBGM();
        UI.show('menu-main');
        // Re-attach safe click handlers to menu buttons
        document.querySelector('#menu-pause button:last-child').onclick = UI.home;
        document.querySelector('#menu-levels button:last-child').onclick = UI.home;
        document.querySelector('#menu-shop button:last-child').onclick = UI.home;
    },

    startPlay: () => {
        UI.showLevels();
    },

    changeLevelPage: (direction) => {
        const maxPage = Math.ceil(CFG.TOTAL_LEVELS / CFG.LEVELS_PER_PAGE);
        currentPage = Math.min(maxPage, Math.max(1, currentPage + direction));
        UI.renderLevelGrid();
    },

    // Improvement 1 Fix: Redesigned Level Grid
    renderLevelGrid: () => {
        const grid = document.getElementById('lvl-grid');
        const prevBtn = document.getElementById('level-prev');
        const nextBtn = document.getElementById('level-next');

        grid.innerHTML = '';

        const start = (currentPage - 1) * CFG.LEVELS_PER_PAGE;
        const end = Math.min(CFG.TOTAL_LEVELS, start + CFG.LEVELS_PER_PAGE);

        for(let i=start; i<end; i++) {
            let b = document.createElement('div');
            b.innerText = i + 1;
            b.className = 'lvl-btn';

            if(i + 1 > unlocked) {
                b.classList.add('locked');
            } else {
                b.classList.add('unlocked');
                b.onclick = () => Game.loadLevel(i);
            }
            grid.appendChild(b);
        }

        // Fill remaining slots if necessary (for 10 slots)
        for(let i=end; i<start + CFG.LEVELS_PER_PAGE; i++) {
            let b = document.createElement('div');
            b.innerText = '';
            b.className = 'lvl-btn locked';
            b.style.opacity = 0.2;
            grid.appendChild(b);
        }

        const maxPage = Math.ceil(CFG.TOTAL_LEVELS / CFG.LEVELS_PER_PAGE);
        prevBtn.disabled = currentPage <= 1;
        nextBtn.disabled = currentPage >= maxPage;
    },

    showLevels: () => {
        UI.renderLevelGrid();
        UI.show('menu-levels');
    },

    // Improvement 1 Fix: Redesigned Shop UI
    renderShop: function() {
        const shopContent = document.getElementById('shop-content');
        shopContent.innerHTML = '';

        SKINS.forEach((skin, index) => {
            const item = document.createElement('div');
            item.className = 'costume-item';

            const isUnlocked = unlockedSkins.includes(index);
            const isEquipped = equippedSkinIndex === index;

            if (isUnlocked) item.classList.add('unlocked');
            if (isEquipped) item.classList.add('equipped');

            const previewHTML = `
                <div class="costume-preview">
                    <div class="player-preview-cube" style="background-color:${skin.main}; border-color:${skin.secondary};">
                        <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:15px; height:15px; background-color:${skin.secondary};"></div>
                        <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:5px; height:5px; background-color:#fff;"></div>
                    </div>
                </div>
            `;

            let actionText = '';
            if (isEquipped) {
                actionText = '<span style="color:var(--accent-green);">EQUIPPED</span>';
            } else if (isUnlocked) {
                actionText = 'Click to Equip';
            } else {
                actionText = `Cost: ${skin.cost} ðŸ’°`;
            }

            item.innerHTML = `
                ${previewHTML}
                <strong>${skin.name}</strong><br>
                <div class="cost">${actionText}</div>
            `;

            item.onclick = (e) => {
                e.stopPropagation();
                if (isUnlocked) {
                    Player.equipSkin(index);
                } else if (totalCoins >= skin.cost) {
                    totalCoins -= skin.cost;
                    unlockedSkins.push(index);
                    localStorage.setItem('nd_skins', JSON.stringify(unlockedSkins));
                    Game.updateCoinDisplay();
                    Player.equipSkin(index);
                } else {
                    alert(`Not enough coins! Requires ${skin.cost} ðŸ’°.`);
                }
            };

            shopContent.appendChild(item);
        });
    },

    showShop: function() {
        UI.renderShop();
        UI.show('menu-shop');
    }
};

// --- INPUT ---
const Input = {
    held: false,
    mousePressed: false
};
const action = () => {
    if(Game.state === 'game') {
        Input.held=true;
        AUDIO.init();

        if (Player.mode !== 'ship' && Player.mode !== 'ufo') {
            Player.jump();
        }
    }
};
const release = () => { Input.held=false; };
const dashAction = () => {
    if(Game.state === 'game' && Player.mode === 'cube') {
        Player.dash();
    }
};
// Mobile dash button handler
Input.dashTouch = (e) => {
    e.preventDefault();
    dashAction();
};

const isUIElement = (target) => {
    // Improvement 4 Fix: Ensure all UI elements are handled
    return target.closest('.ui-layer') || target.closest('.mobile-btn') || target.tagName === 'BUTTON' || target.classList.contains('lvl-btn') || target.classList.contains('costume-item');
};

Input.touchStartAction = (e) => {
    e.preventDefault();
    Input.mousePressed = true;
    action();
};
Input.touchEndAction = (e) => {
    e.preventDefault();
    Input.mousePressed = false;
    release();
};

window.onkeydown = (e) => {
    if(e.repeat) return;

    if(e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        action();
    }
    else if (e.code === 'KeyD') { // Added 'D' for explicit dash
        dashAction();
    }
    else if (e.code === 'KeyR') {
        Game.retry();
    }
    else if (e.code === 'Escape' && (Game.state==='game' || Game.state==='dead' || Game.state==='win')) {
        UI.home();
    }
};

window.onkeyup = (e) => {
    if(e.code === 'Space' || e.code === 'ArrowUp') {
        release();
    }
};

window.onmousedown = (e) => {
    if(!isUIElement(e.target) && Game.state === 'game') {
        Input.mousePressed = true;
        action();
    }
};

window.onmouseup = () => {
    Input.mousePressed = false;
    release();
};

window.ontouchstart = (e) => {
    if (isUIElement(e.target) && !e.target.classList.contains('mobile-btn')) return;
    Input.mousePressed = true;
};

window.ontouchend = () => {
    Input.mousePressed = false;
};

// Improvement 4 Fix: Ensure return buttons use the correct handler on init
document.querySelector('#menu-pause button:last-child').onclick = UI.home;
document.querySelector('#menu-levels button:last-child').onclick = UI.home;
document.querySelector('#menu-shop button:last-child').onclick = UI.home;

Game.init();
</script>
</body>
</html>
